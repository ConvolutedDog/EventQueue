res =
    LaunchOpBuilder(signal, processor, ValueRange{accel}, [&](ValueRange ins) {
      accel = ins[0];
      Value ifmap;
      Value filter;
      Value ofmap;
      processor = get_comp(accel, "proc");

      dma_row = get_comp(accel, "dma_row");
      dma_col = get_comp(accel, "dma_col");
      SmallVector<Value, 20> dma_rows, dma_cols;

      for (int i = accel_config.array_height - 1; i >= 0; i--) {
        dma_rows.push_back(get_comp(dma_row, "dma"));
        if (i != 0)
          dma_row = get_comp(dma_row, "dma_row");
      }
      for (int i = accel_config.array_width - 1; i >= 0; i--) {
        dma_cols.push_back(get_comp(dma_col, "dma"));
        if (i != 0)
          dma_col = get_comp(dma_col, "dma_col");
      }

      sram = get_comp(accel, "sram");
      Value ibuffer = alloc_op(sram,
                               ArrayRef<int64_t>{layer_config.channel,
                                                 layer_config.ifmap_height,
                                                 layer_config.ifmap_width},
                               32, f32Type);
      Value wbuffer = alloc_op(sram,
                               ArrayRef<int64_t>{layer_config.num_filter,
                                                 layer_config.channel,
                                                 layer_config.ifmap_width,
                                                 layer_config.filter_width},
                               32, f32Type);
      Value obuffer =
          alloc_op(sram, ArrayRef<int64_t>{layer_config.num_filter, E_h, E_w},
                   32, f32Type);

      SmallVector<SmallVector<Value, 20>, 20> pes, mems, procs;
      SmallVector<SmallVector<Value, 20>, 20> wbuffer2s, obuffer2s, ibuffer2s;
      Value wbuffer2, obuffer2, ibuffer2;

      Value pe;

      for (int i = accel_config.array_height - 1; i >= 0; i--) {
        SmallVector<Value, 20> line_pe, line_mem, line_proc;
        SmallVector<Value, 20> line_wbuffer, line_obuffer, line_ibuffer;
        for (int j = accel_config.array_width - 1; j >= 0; j--) {
          if (j == accel_config.array_width - 1 &&
              i == accel_config.array_height - 1) {
            pe = get_comp(accel, "pe_array");
          } else {
            pe = get_comp(pe, "pes");
          }

          mem = get_comp(pe, "mem");
          proc = get_comp(pe, "proc");
          wbuffer2 = alloc_op(mem, ArrayRef<int64_t>{1}, 32, f32Type);
          obuffer2 = alloc_op(mem, ArrayRef<int64_t>{1}, 32, f32Type);
          ibuffer2 = alloc_op(mem, ArrayRef<int64_t>{1}, 32, f32Type);

          line_pe.push_back(pe);
          line_mem.push_back(mem);
          line_proc.push_back(proc);
          line_wbuffer.push_back(wbuffer2);
          line_obuffer.push_back(obuffer2);
          line_ibuffer.push_back(ibuffer2);
        }
        pes.push_back(line_pe);
        mems.push_back(line_mem);
        procs.push_back(line_proc);
        wbuffer2s.push_back(line_wbuffer);
        obuffer2s.push_back(line_obuffer);
        ibuffer2s.push_back(line_ibuffer);
      }

      int last_width = layer_config.num_filter % accel_config.array_width;
      if (last_width == 0)
        last_width = accel_config.array_width;
      int last_height = e2 % accel_config.array_height;
      if (last_height == 0)
        last_height = accel_config.array_height;
      int total_cycles =
          num_v_fold * num_h_fold * px_per_conv + last_width + last_height;
      for (int t = 0;
           t < num_v_fold * num_h_fold * px_per_conv + last_width + last_height;
           t++) {
        int col_this_fold = ceil((float)layer_config.num_filter /
                                 ceil((float)layer_config.num_filter /
                                      (float)accel_config.array_width));
        int row_this_fold = ceil(
            (float)e2 / ceil((float)e2 / (float)accel_config.array_height));

        Value start_cpy = start_op();
        Value c0 = std_constant_index(0);

        Value start_compute_signal = start_op();
        Value compute_signal, prev_compute_signal;
        SmallVector<SmallVector<Value, 20>, 20> ifmap_flight, filter_flight,
            ofmap_flight;
        Value non = std_constant_index(100);
        for (int r = 0; r < row_this_fold; r++) {
          SmallVector<Value, 20> ifmap_flight_line, filter_flight_line,
              ofmap_flight_line;
          for (int c = 0; c < col_this_fold; c++) {
            ValueRange pe_res;
            if (c == 0 && r == 0) {
              pe_res = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{ibuffer, wbuffer, obuffer2s[r][c]},
                  [&](ValueRange ins) {
                    if (t >= r + c &&
                        ((r < last_height && c < last_width &&
                          t < r + c + num_v_fold * num_h_fold * px_per_conv) ||
                         (r < last_height && t < r + c +
                                                     (num_v_fold - 1) *
                                                         num_h_fold *
                                                         px_per_conv) ||
                         (c < last_width && t < r + c +
                                                    num_v_fold *
                                                        (num_h_fold - 1) *
                                                        px_per_conv) ||
                         t < r + c +
                                 (num_v_fold - 1) * (num_h_fold - 1) *
                                     px_per_conv)) {

                      filter = read_op(ins[1], ArrayRef<int64_t>{1}, c);
                      ifmap = read_op(ins[0], ArrayRef<int64_t>{1},
                                      col_this_fold + r);
                    } else {
                      filter = non;
                      ifmap = non;
                    }

                    Value ofmap = non;
                    if (ifmap != non && filter != non) {
                      ofmap = read_op(ins[2], ArrayRef<int64_t>{1}, 2);
                    }
                    unk_op("mac", ValueRange{ofmap, ifmap, filter}, f32Type);
                    return_op(ValueRange{ifmap, filter, ofmap});
                  });
            } else if (c == 0) {
              pe_res = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{ibuffer, wbuffer2s[r][c], obuffer2s[r][c]},
                  [&](ValueRange ins) {
                    if (t >= r + c &&
                        ((r < last_height && c < last_width &&
                          t < r + c + num_v_fold * num_h_fold * px_per_conv) ||
                         (r < last_height && t < r + c +
                                                     (num_v_fold - 1) *
                                                         num_h_fold *
                                                         px_per_conv) ||
                         (c < last_width && t < r + c +
                                                    num_v_fold *
                                                        (num_h_fold - 1) *
                                                        px_per_conv) ||
                         t < r + c +
                                 (num_v_fold - 1) * (num_h_fold - 1) *
                                     px_per_conv)) {

                      filter = read_op(ins[1], ArrayRef<int64_t>{1}, c);
                      ifmap = read_op(ins[0], ArrayRef<int64_t>{1},
                                      col_this_fold + r);
                    } else {
                      filter = non;
                      ifmap = non;
                    }
                    Value ofmap = non;
                    if (ifmap != non && filter != non) {
                      ofmap = read_op(ins[2], ArrayRef<int64_t>{1}, 2);
                    }
                    unk_op("mac", ValueRange{ofmap, ifmap, filter}, f32Type);
                    return_op(ValueRange{ifmap, filter, ofmap});
                  });
            } else if (r == 0) {
              pe_res = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{ibuffer2s[r][c], wbuffer, obuffer2s[r][c]},
                  [&](ValueRange ins) {
                    if (t >= r + c &&
                        ((r < last_height && c < last_width &&
                          t < r + c + num_v_fold * num_h_fold * px_per_conv) ||
                         (r < last_height && t < r + c +
                                                     (num_v_fold - 1) *
                                                         num_h_fold *
                                                         px_per_conv) ||
                         (c < last_width && t < r + c +
                                                    num_v_fold *
                                                        (num_h_fold - 1) *
                                                        px_per_conv) ||
                         t < r + c +
                                 (num_v_fold - 1) * (num_h_fold - 1) *
                                     px_per_conv)) {

                      filter = read_op(ins[1], ArrayRef<int64_t>{1}, c);
                      ifmap = read_op(ins[0], ArrayRef<int64_t>{1},
                                      col_this_fold + r);
                    } else {
                      filter = non;
                      ifmap = non;
                    }
                    Value ofmap = non;
                    if (ifmap != non && filter != non) {
                      ofmap = read_op(ins[2], ArrayRef<int64_t>{1}, 2);
                    }
                    unk_op("mac", ValueRange{ofmap, ifmap, filter}, f32Type);
                    return_op(ValueRange{ifmap, filter, ofmap});
                  });
            } else {
              pe_res = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{ibuffer2s[r][c], wbuffer2s[r][c], obuffer2s[r][c]},
                  [&](ValueRange ins) {
                    if (t >= r + c &&
                        ((r < last_height && c < last_width &&
                          t < r + c + num_v_fold * num_h_fold * px_per_conv) ||
                         (r < last_height && t < r + c +
                                                     (num_v_fold - 1) *
                                                         num_h_fold *
                                                         px_per_conv) ||
                         (c < last_width && t < r + c +
                                                    num_v_fold *
                                                        (num_h_fold - 1) *
                                                        px_per_conv) ||
                         t < r + c +
                                 (num_v_fold - 1) * (num_h_fold - 1) *
                                     px_per_conv)) {

                      filter = read_op(ins[1], ArrayRef<int64_t>{1}, c);
                      ifmap = read_op(ins[0], ArrayRef<int64_t>{1},
                                      col_this_fold + r);
                    } else {
                      filter = non;
                      ifmap = non;
                    }
                    Value ofmap = non;
                    if (ifmap != non && filter != non) {
                      ofmap = read_op(ins[2], ArrayRef<int64_t>{1}, 2);
                    }
                    unk_op("mac", ValueRange{ofmap, ifmap, filter}, f32Type);
                    return_op(ValueRange{ifmap, filter, ofmap});
                  });
            }

            /*if(t>=r+c && t < r+c+num_v_fold*num_h_fold*px_per_conv){
              llvm::outs()<<t<<" :"<<r<<", "<<c<<"\n";
            }*/
            compute_signal = pe_res[0];
            ifmap_flight_line.push_back(pe_res[1]);
            filter_flight_line.push_back(pe_res[2]);
            ofmap_flight_line.push_back(pe_res[3]);
            if (c == 0 && r == 0) {
              prev_compute_signal = compute_signal;
            } else {
              prev_compute_signal =
                  control_and(ValueRange{prev_compute_signal, compute_signal});
            }
          }
          ifmap_flight.push_back(ifmap_flight_line);
          filter_flight.push_back(filter_flight_line);
          ofmap_flight.push_back(ofmap_flight_line);
        }
        await_op(ValueRange{prev_compute_signal});

        start_compute_signal = start_op();

        for (int c = 0; c < col_this_fold; c++) {
          for (int r = 0; r < row_this_fold; r++) {
            if (c != col_this_fold - 1 && r != row_this_fold - 1) {
              compute_signal = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{ifmap_flight[r][c], filter_flight[r][c],
                             ofmap_flight[r][c], obuffer2s[r][c],
                             ibuffer2s[r][c + 1], wbuffer2s[r + 1][c], obuffer},
                  [&](ValueRange ins) {
                    ifmap = ins[0];
                    if (!ifmap.getType().isIndex()) {
                      write_op(ifmap, ins[4], ArrayRef<int64_t>{1}, 1);
                    }
                    filter = ins[1];
                    if (!filter.getType().isIndex()) {
                      write_op(filter, ins[5], ArrayRef<int64_t>{1});
                    }
                    ofmap = ins[2];
                    if (!ofmap.getType().isIndex()) {
                      if (t >= c + r &&
                          t + c + r <= num_v_fold * num_h_fold * px_per_conv +
                                           last_width + last_height) {
                        if ((t - c - r) % px_per_conv == 0) {
                          c0 = std_constant_float(llvm::APFloat(0.0f), f32Type);
                          write_op(c0, ins[3], ArrayRef<int64_t>{1}, 2);
                          write_op(ofmap, ins[6], ArrayRef<int64_t>{1}, c);
                        } else {
                          write_op(ofmap, ins[3], ArrayRef<int64_t>{1}, 2);
                        }
                      }
                    }
                    return_op(ValueRange{});
                  })[0];
            } else if (c == col_this_fold - 1 && r != row_this_fold - 1) {
              compute_signal = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{filter_flight[r][c], ofmap_flight[r][c],
                             obuffer2s[r][c], wbuffer2s[r + 1][c], obuffer},
                  [&](ValueRange ins) {
                    filter = ins[0];
                    if (!filter.getType().isIndex()) {
                      write_op(filter, ins[3]);
                    }
                    ofmap = ins[1];
                    if (!ofmap.getType().isIndex()) {
                      if (t >= c + r &&
                          t + c + r <= num_v_fold * num_h_fold * px_per_conv +
                                           last_width + last_height) {
                        if ((t - c - r) % px_per_conv == 0) {
                          c0 = std_constant_float(llvm::APFloat(0.0f), f32Type);
                          write_op(c0, ins[2], ArrayRef<int64_t>{1}, 2);
                          write_op(ofmap, ins[4], ArrayRef<int64_t>{1}, c);
                        } else {
                          write_op(ofmap, ins[2], ArrayRef<int64_t>{1}, 2);
                        }
                      }
                    }
                    return_op(ValueRange{});
                  })[0];
            } else if (c != col_this_fold - 1 && r == row_this_fold - 1) {
              compute_signal = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{ifmap_flight[r][c], ofmap_flight[r][c],
                             obuffer2s[r][c], ibuffer2s[r][c + 1], obuffer},
                  [&](ValueRange ins) {
                    ifmap = ins[0];
                    if (!ifmap.getType().isIndex()) {
                      write_op(ifmap, ins[3], 1);
                    }
                    ofmap = ins[1];
                    if (!ofmap.getType().isIndex()) {
                      if (t >= c + r &&
                          t + c + r <= num_v_fold * num_h_fold * px_per_conv +
                                           last_width + last_height) {
                        if ((t - c - r) % px_per_conv == 0) {
                          c0 = std_constant_float(llvm::APFloat(0.0f), f32Type);
                          write_op(c0, ins[2], ArrayRef<int64_t>{1}, 2);
                          write_op(ofmap, ins[4], ArrayRef<int64_t>{1}, c);
                        } else {
                          write_op(ofmap, ins[2], ArrayRef<int64_t>{1}, 2);
                        }
                      }
                    }
                    return_op(ValueRange{});
                  })[0];
            } else {
              compute_signal = LaunchOpBuilder(
                  start_compute_signal, procs[r][c],
                  ValueRange{ofmap_flight[r][c], obuffer2s[r][c], obuffer},
                  [&](ValueRange ins) {
                    ofmap = ins[0];
                    if (!ofmap.getType().isIndex()) {
                      if (t >= c + r &&
                          t + c + r <= num_v_fold * num_h_fold * px_per_conv +
                                           last_width + last_height) {
                        if ((t - c - r) % px_per_conv == 0) {
                          c0 = std_constant_float(llvm::APFloat(0.0f), f32Type);
                          write_op(c0, ins[1], ArrayRef<int64_t>{1}, 2);
                          write_op(ofmap, ins[2], ArrayRef<int64_t>{1}, c);
                        } else {
                          write_op(ofmap, ins[1], ArrayRef<int64_t>{1}, 2);
                        }
                      }
                    }
                    return_op(ValueRange{});
                  })[0];
            }
            if (c == 0 && r == 0) {
              prev_compute_signal = compute_signal;
            } else {
              prev_compute_signal =
                  control_and(ValueRange{prev_compute_signal, compute_signal});
            }
          }
        }
        await_op(ValueRange{prev_compute_signal});
      }
      return_op(ValueRange{});
    });
