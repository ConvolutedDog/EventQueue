res =
    LaunchOpBuilder(signal, processor, ValueRange{accel}, [&](ValueRange ins) {
      accel = ins[0];
      Value ifmap;
      Value filter;
      Value ofmap;
      processor = get_comp(accel, "proc");

      dma_row = get_comp(accel, "dma_row");
      dma_col = get_comp(accel, "dma_col");
      SmallVector<Value, 20> dma_rows, dma_cols;

      for (int i = accel_config.array_height - 1; i >= 0; i--) {
        dma_rows.push_back(get_comp(dma_row, "dma"));
        if (i != 0)
          dma_row = get_comp(dma_row, "dma_row");
      }
      for (int i = accel_config.array_width - 1; i >= 0; i--) {
        dma_cols.push_back(get_comp(dma_col, "dma"));
        if (i != 0)
          dma_col = get_comp(dma_col, "dma_col");
      }

      sram = get_comp(accel, "sram");
      Value ibuffer = alloc_op(sram,
                               ArrayRef<int64_t>{layer_config.channel,
                                                 layer_config.ifmap_height,
                                                 layer_config.ifmap_width},
                               32, f32Type);
      Value wbuffer = alloc_op(sram,
                               ArrayRef<int64_t>{layer_config.num_filter,
                                                 layer_config.channel,
                                                 layer_config.ifmap_width,
                                                 layer_config.filter_width},
                               32, f32Type);
      Value obuffer =
          alloc_op(sram, ArrayRef<int64_t>{layer_config.num_filter, E_h, E_w},
                   32, f32Type);

      SmallVector<SmallVector<Value, 20>, 20> pes, mems, procs;
      SmallVector<SmallVector<Value, 20>, 20> wbuffer2s, obuffer2s, ibuffer2s;
      Value wbuffer2, obuffer2, ibuffer2;
      Value pe;

      for (int i = accel_config.array_height - 1; i >= 0; i--) {
        SmallVector<Value, 20> line_pe, line_mem, line_proc;
        SmallVector<Value, 20> line_wbuffer, line_obuffer, line_ibuffer;
        for (int j = accel_config.array_width - 1; j >= 0; j--) {
          if (j == accel_config.array_width - 1 &&
              i == accel_config.array_height - 1) {
            pe = get_comp(accel, "pe_array");
          } else {
            pe = get_comp(pe, "pes");
          }

          mem = get_comp(pe, "mem");
          proc = get_comp(pe, "proc");
          wbuffer2 = alloc_op(mem, ArrayRef<int64_t>{1}, 32, f32Type);
          obuffer2 = alloc_op(mem, ArrayRef<int64_t>{1}, 32, f32Type);
          ibuffer2 = alloc_op(mem, ArrayRef<int64_t>{1}, 32, f32Type);

          line_pe.push_back(pe);
          line_mem.push_back(mem);
          line_proc.push_back(proc);
          line_wbuffer.push_back(wbuffer2);
          line_obuffer.push_back(obuffer2);
          line_ibuffer.push_back(ibuffer2);
        }
        pes.push_back(line_pe);
        mems.push_back(line_mem);
        procs.push_back(line_proc);
        wbuffer2s.push_back(line_wbuffer);
        obuffer2s.push_back(line_obuffer);
        ibuffer2s.push_back(line_ibuffer);
      }

      for (int i = 0; i < num_v_fold; i++) {
        int col_this_fold =
            min(remaining_cols, max_parallel_conv * accel_config.array_width);
        remaining_cols -= col_this_fold;
        int rem_h = px_per_conv;
        for (int j = 0; j < num_h_fold; j++) {
          int row_this_fold = min(rem_h, accel_config.array_height);
          rem_h -= row_this_fold;

          Value c0 = std_constant_index(0);
          Value start_cpy;
          Value cpy, prev_cpy;

          for (int t = 0; t < row_this_fold; t++) {
            if (t > 0) {
              start_cpy = start_op();
              SmallVector<SmallVector<Value, 20>, 20> ifmap_flight;
              for (int r = 0; r < row_this_fold - 1; r++) {
                SmallVector<Value, 20> ifmap_flight_line;
                for (int c = 0; c < col_this_fold; c++) {
                  auto pe_res = LaunchOpBuilder(
                      start_cpy, procs[r][c], ValueRange{wbuffer2s[r][c]},
                      [&](ValueRange ins) {
                        value = read_op(ins[0], ArrayRef<int64_t>{1});
                        return_op(ValueRange{value});
                      });
                  cpy = pe_res[0];
                  ifmap_flight_line.push_back(pe_res[1]);
                  if (c == 0 && r == 0) {
                    prev_cpy = control_and(ValueRange{cpy});
                  } else {
                    prev_cpy = control_and(ValueRange{prev_cpy, cpy});
                  }
                }
                ifmap_flight.push_back(ifmap_flight_line);
              }
              await_op(ValueRange{prev_cpy});

              start_cpy = start_op();
              for (int r = 0; r < row_this_fold - 1; r++) {
                for (int c = 0; c < col_this_fold; c++) {
                  cpy = LaunchOpBuilder(
                      start_cpy, procs[r][c],
                      ValueRange{ifmap_flight[r][c], wbuffer2s[r + 1][c]},
                      [&](ValueRange ins) {
                        write_op(ins[0], ins[1], ArrayRef<int64_t>{1});
                        return_op(ValueRange{});
                      })[0];
                  if (c == 0 && r == 0) {
                    prev_cpy = control_and(ValueRange{cpy});
                  } else {
                    prev_cpy = control_and(ValueRange{prev_cpy, cpy});
                  }
                }
              }
              await_op(ValueRange{prev_cpy});
            }

            start_cpy = start_op();

            for (int c = 0; c < col_this_fold; c++) {
              cpy = memcpy_op(start_cpy, wbuffer, wbuffer2s[0][c], dma_cols[c],
                              ArrayRef<int64_t>{1}, c, 0);
              if (c == 0) {
                prev_cpy = control_and(ValueRange{cpy});
              } else {
                prev_cpy = control_and(ValueRange{prev_cpy, cpy});
              }
            }
            if (t == row_this_fold - 1) {
              Value memcpy_signal, prev_memcpy_signal;
              for (int r = 0; r < row_this_fold; r++) {
                memcpy_signal =
                    memcpy_op(start_cpy, ibuffer, ibuffer2s[r][0], dma_rows[r],
                              ArrayRef<int64_t>{1}, col_this_fold + r, 1);
                if (r == 0) {
                  prev_memcpy_signal = memcpy_signal;
                } else {
                  prev_memcpy_signal = control_and(
                      ValueRange{prev_memcpy_signal, memcpy_signal});
                }
              }
              await_op(ValueRange{prev_cpy, prev_memcpy_signal});
            } else {
              await_op(ValueRange{prev_cpy});
            }
          }

          for (int t = 0; t < e2 + row_this_fold + col_this_fold; t++) {

            Value compute_signal, prev_compute_signal;
            Value start_compute_signal = start_op();
            SmallVector<SmallVector<Value, 20>, 20> ifmap_flight, ofmap_flight;
            for (int r = 0; r < row_this_fold; r++) {
              SmallVector<Value, 20> ifmap_flight_line, ofmap_flight_line;
              for (int c = 0; c < col_this_fold; c++) {
                auto pe_res = LaunchOpBuilder(
                    start_compute_signal, procs[r][c],
                    ValueRange{ibuffer2s[r][c], wbuffer2s[r][c],
                               obuffer2s[r][c]},
                    [&](ValueRange ins) {
                      ifmap = read_op(ins[0], ArrayRef<int64_t>{1});
                      filter = read_op(ins[1], ArrayRef<int64_t>{1}, 1);
                      Value ofmap = read_op(ins[2], ArrayRef<int64_t>{1}, 2);
                      unk_op("mac", ValueRange{ofmap, ifmap, filter}, f32Type);
                      return_op(ValueRange{ifmap, ofmap});
                    });
                compute_signal = pe_res[0];
                ifmap_flight_line.push_back(pe_res[1]);
                ofmap_flight_line.push_back(pe_res[2]);

                if (c == 0 && r == 0) {
                  prev_compute_signal = compute_signal;
                } else {
                  prev_compute_signal = control_and(
                      ValueRange{prev_compute_signal, compute_signal});
                }
              }
              ifmap_flight.push_back(ifmap_flight_line);
              ofmap_flight.push_back(ofmap_flight_line);
            }
            if (t < e2 - 1) {
              Value memcpy_signal, prev_memcpy_signal;
              for (int r = 0; r < row_this_fold; r++) {
                memcpy_signal =
                    memcpy_op(start_cpy, ibuffer, ibuffer2s[r][0], dma_rows[r],
                              ArrayRef<int64_t>{1}, col_this_fold + r, 1);
                if (r == 0) {
                  prev_memcpy_signal = memcpy_signal;
                } else {
                  prev_memcpy_signal = control_and(
                      ValueRange{prev_memcpy_signal, memcpy_signal});
                }
              }
              await_op(ValueRange{prev_compute_signal, prev_memcpy_signal});
            } else {
              await_op(ValueRange{prev_compute_signal});
            }
            start_compute_signal = start_op();
            for (int r = 0; r < row_this_fold; r++) {
              for (int c = 0; c < col_this_fold; c++) {
                if (c != col_this_fold - 1 && r != row_this_fold - 1) {
                  compute_signal = LaunchOpBuilder(
                      start_compute_signal, procs[r][c],
                      ValueRange{ifmap_flight[r][c], ofmap_flight[r][c],
                                 ibuffer2s[r][c + 1], obuffer2s[r + 1][c]},
                      [&](ValueRange ins) {
                        ifmap = ins[0];
                        write_op(ifmap, ins[2], ArrayRef<int64_t>{1});
                        ofmap = ins[1];
                        if (r + c + 1 < t && c >= t - e2 - row_this_fold) {
                          write_op(ofmap, ins[3], ArrayRef<int64_t>{1}, 2);
                        }
                        return_op(ValueRange{});
                      })[0];
                } else if (c == col_this_fold - 1 && r != row_this_fold - 1) {
                  compute_signal = LaunchOpBuilder(
                      start_compute_signal, procs[r][c],
                      ValueRange{ofmap_flight[r][c], obuffer2s[r + 1][c]},
                      [&](ValueRange ins) {
                        ofmap = ins[0];
                        if (r + c + 1 < t && c >= t - e2 - row_this_fold) {
                          write_op(ofmap, ins[1], ArrayRef<int64_t>{1}, 2);
                        }
                        return_op(ValueRange{});
                      })[0];
                } else if (c != col_this_fold - 1 && r == row_this_fold - 1) {
                  compute_signal = LaunchOpBuilder(
                      start_compute_signal, procs[r][c],
                      ValueRange{ifmap_flight[r][c], ofmap_flight[r][c],
                                 ibuffer2s[r][c + 1], obuffer},
                      [&](ValueRange ins) {
                        ifmap = ins[0];
                        write_op(ifmap, ins[2], ArrayRef<int64_t>{1});
                        ofmap = ins[1];
                        if (t > c + r + 1 && t <= c + e2 + row_this_fold) {
                          write_op(ofmap, ins[3], ArrayRef<int64_t>{1}, c);
                        }
                        return_op(ValueRange{});
                      })[0];
                } else {
                  compute_signal = LaunchOpBuilder(
                      start_compute_signal, procs[r][c],
                      ValueRange{ofmap_flight[r][c], obuffer},
                      [&](ValueRange ins) {
                        ofmap = ins[0];
                        if (t > c + r + 1 && t <= c + e2 + row_this_fold) {
                          write_op(ofmap, ins[1], ArrayRef<int64_t>{1}, c);
                        }
                        return_op(ValueRange{});
                      })[0];
                }
                if (c == 0 && r == 0) {
                  prev_compute_signal = compute_signal;
                } else {
                  prev_compute_signal = control_and(
                      ValueRange{prev_compute_signal, compute_signal});
                }
              }
            }
            await_op(ValueRange{prev_compute_signal});
          }
        }
      }
      return_op(ValueRange{});
    });
